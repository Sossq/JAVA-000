学习笔记
类加载步骤：
1、加载
通过全限定类名来获取定义此类的二进制字节流。
将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口
2、验证，确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求
文件格式验证：如是否以魔数 0xCAFEBABE 开头、主、次版本号是否在当前虚拟机处理范围之内、常量合理性验证等。此阶段保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个 Java类型信息的要求。
元数据验证：是否存在父类，父类的继承链是否正确，抽象类是否实现了其父类或接口之中要求实现的所有方法，字段、方法是否与父类产生矛盾等。第二阶段，保证不存在不符合 Java 语言规范的元数据信息。
字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。例如保证跳转指令不会跳转到方法体以外的字节码指令上。
符号引用验证：在解析阶段中发生，保证可以将符号引用转化为直接引用。
3、准备
为类变量分配内存并设置类变量初始值，这些变量所使用的内存都将在方法区中进行分配
4、解析
虚拟机将常量池内的符号引用替换为直接引用的过程。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行
5、初始化
执行构造器
静态变量赋值
静态代码块
初始化时机
遇到特定字节码指令，new,getstatis,putstatic,invokestatic
指令最常见场景
使用new关键字实例化对象
读取或设置类的静态字段(被final修饰，已在编译器把结果放入常量池的静态字段外)
调用类静态方法
reflect包进行反射调用时，如果类没有进行初始化
初始化类时发现其父类没有进行初始化 则先触发父类初始化
当虚拟机启动时，用户需要指定一个执行类
使用jdk1.7动态语言支持时
不会初始化（可能会加载）：
通过子类引用父类的静态字段，只会触发父类的初始化，不会触发子类的初始化
定义对象数组，不会触发该类的初始化
常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量的类
通过类名获取class对象不会触发类的初始化，Hello.class不会让Hello类初始化
通过Class.forName加载指定类时，如果指定参数initialize为false时，也不会触发类初始化，其实这个参数告诉虚拟机，是否要对类进行初始化。Class.forName(“jvm.hello”)默认会加载Hello类。
通过ClassLoader默认的loadClass方法，也不会触发初始化动作（加载了，但是不初始化）
类加载器：
类的唯一性和类加载器
任何一个类，都需要由加载它的类加载器和这个类本身一同确定其在java虚拟机中的唯一性，每一个类加载器都有一个独立的类名称空间

加载器
启动类加载器
扩展类加载器
应用类加载器
加载器特点
双亲委派
负责依赖
缓存加载
双亲委派模型：
要求除顶层的启动类加载器外，其余类加载器都应该有自己的父类加载器(通过组合关系复用父加载器)
如果一个类加载器收到了类加载请求，首先不会自己处理，而是委派给父类加载器处理，每层如此，因此所有的加载请求都应该传送到顶层的启动类加载器中，只有当父类加载器反馈无法完成加载请求时子类加载器才会尝试加载
加载器加载顺序：Bootstrap ClassLoader > Extention ClassLoader > Appclass Loader
安全性，性能；（避免重复加载 和 避免核心类被篡改）
破坏双亲委派：
SPI加载，例如加载JDBC
应用
类层次划分
OSGi
热部署
代码加密
外部资源加载
